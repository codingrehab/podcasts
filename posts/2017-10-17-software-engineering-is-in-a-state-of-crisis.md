---
title: software-engineering-is-in-a-state-of-crisis
summary: Discussion on the current state of software engineering.
soundcloud: 333520893
author: David Taylor
---

# Software engineering is in a state of crisis. 

To make matters worse, the community doesn’t seem to care. Look no further than those currently hiring; Read their job descriptions. For a community of self-proclaimed data-driven people — capable of solving the worlds greatest problems — I’ve not seen a greater dichotomy in behavior and expectation. 

In the search for top-talent we’ve propped up a stereotyped which drives our hiring practices, yet doesn’t represent what we truly want: someone who will raise our chances of success. This search for a comic book character has created a community focused on traits least likely to achieve our project’s mission.  [We want A, but are writing job descriptions — and hire — for B](www.sba.oakland.edu/Faculty/york/Readings434/Readings/On the folly.pdf). I believe we want reliable software, achieving some objective, delivered in a reasonable timeframe and under a certain budget. 

The software community searches for an outlier and focuses on individualism. A natural recluse, dedicating every waking hour to the development of software programs: naturally, built with complex algorithms. Someone who, at the young age of 16, has years of experience with all of the latest hype words. Rejected by mainstream society — due to his contrarian ways — at night he’s solving the world's problems, waiting for your job requisition — accompanied with the promise of below-market salary. 

Given our industry's current state of crisis, Is it any wonder that our community rewards: unsustainable development processes, unreviewed code, untested programs, overly-complex languages and architectures, and fire-driven management practices? We openly celebrate mantras like move fast and break things. And we reward them in the literal sense. We literally hire — and pay more — those least likely to help deliver what we want. We know that a [https://www.quora.com/Is-there-a-link-between-job-interview-performance-and-job-performance](great performance) in our interview process doesn’t correlate to great job performance, yet we still [require](https://hired.com/blog/employers/whiteboard-interview-alternatives/) overly-complex wizardry: through which the worthy must pass, to bestow upon them the honor of failing with us. Hooray! The ship is sinking, but one can take solemn in the fact that everyone about to drown can invert a binary tree from memory. 

The software development community is aware that [most software projects fail](https://www.projectsmart.co.uk/white-papers/chaos-report.pdf). However, I wonder why they’re not bothered by it? Or even attempting to change. Have you ever seen a community more readily accept the status-quo of failure? If we are aware of our inability to succeed, why do we continue to perpetuate this false ideal, instead of adapting our behavior: when we know where it leads? Worse, why do we make it difficult for anyone who recognizes it and attempts to manage differently? 

For every successful team, I find there is a dedicated politician spending most of her professional effort fighting this systemic assumption that software gets built over-night — on an Adderall induced bender.  Ironically, this assumption is the greatest obstruction preventing leaders from sustainably building a team — and software — that are capable of achieving what everyone wants. Not only are teams required to solve the difficult problems of their respective technical domains, They’re constantly fighting the current standard management practices of shifting priorities, late hours and rapid context switching. What most seem to not understand is that their concept of top performing behavior is actually team poison. Accordingly, those who know better find themselves forced to behave, as the lead candidate in an election cycle — glamorizing success and deflecting inquiries into troublesome areas— simply to remove needless complexity. Largely due to our community, which has incorrectly defined successful behavior — [despite evidence to the contrary](https://www.inc.com/robin-camarote/google-says-these-5-characteristics-can-make-or-br.html).  

This is a leadership problem. It can be directly attributed to our leader's inability to define standards, processes, and norms which match the capability of a team of good engineers — instead of an outright fantasy.  If a prodigious engineer is an outlier, logic would reason that our expectations, capacity planning, and processes — for a team of multiple engineers — wouldn’t assume it is completely composed of a real-life version of the technical prodigy playing the supporting character in a blockbuster film. 

Software leadership must rehabilitate. It will take constant work. Their goals and expectations must adjust to prevent the creation of a team of exceptionally smart engineers, doomed to failure. This stigma of — manage like everyone is an outlier — has existed so long, that it has bled into every facet of programming. Which is far far more complex than necessary. Our tools, algorithms, hiring practices, languages, education programs, and work environments have needless complexity — which only exacerbates failure. At times it seems we've purposefully made it complex, simply to justify our role in this world. 

Ironically, strong software leadership will find the most complex part of their work promoting simplicity. They must heretically argue against the status quo and spend an inordinate amount of effort pushing for simple, clear and proven development practices — simply because they are unglamorous, counter-culture, and void of hype — to deliver the product they've been asked to deliver. 

Leadership which focuses on the simplification of programming will find themselves vouching for the following: 

Optimize for the team, not the individual; Hire Accordingly. 
Time is finite; Plan accordingly.
How you build something is as important as what you build.
You can do a lot of things bad, or a few things well  


Optimize for the team, not the individual; Hire Accordingly. 10x engineers — if they exist — are rare. 10x teams can be built: and don't need to be rare. The decision making surrounding the development, status, improvement, and welfare of the team should be made under the context of each team member being human. And, each crucial decision should consider the question: how will this affect the team's ability to deliver? Small improvements within a team will have exponentially better net rewards when compared to large improvements in an individual. Leadership should adjust focus appropriately. 

Time is finite; Plan accordingly. There is a surprising lack of association between a feature request and the cost of that request from management, product owners, and program managers. Often, strong software leadership finds themselves having to remind their incredibly bright and qualified peers, of the weight behind the last-minute ill-planned request.  A strict focus on priority, direction, and recognition of the weight of each diversion is crucial. Unfortunately, a failed product is more naturally associated with the development team than those with a seemingly endless ability to “innovate”: ask for things without any comprehension of time, value, investment and opportunity cost. The onus falls solely upon strong software leadership to: understand your team’s capacity, clearly communicate your priorities, detail the consequences, and place accountability of diversions back onto the requester. 

How you build something is as important as what you build. Quickly dispel the myth that someone on your team can crush three red bulls, and complete a spontaneous request by morning. This is bad management practice and rewards the wrong behavior; It will have detrimental long-term effects on your product and team. Engineers trying to live up to the mythos of a 10x engineer will often respond to a last minute change request — before the next-days deadline — with, “I’ll have it done tomorrow”. Aware that this represents both an opportunity for the engineer to shine, and is exactly what a manager — incapable of prioritizing and proper planning — wants to hear, we must force ourselves to remember that no tests, no code review, manual deployment, and high-risk code pushed into prod — by a unrested engineer — is a horrible idea. It helps to remove the mystic behind the myth and remind one of reality. Leadership must be forced to exercise discipline and understand that while the team may be capable of doing something, should they?  When the previously mentioned code breaks, it will take twice as long to find and write properly, when compared to doing it right in the first place. Further, the embarrassment saved from pushing bad code into a client-facing product was worse than a stable application — minus that feature. It’s far more preferable to disappoint upper management now — by reminding them of the team's humanity and coding standards — than it will be later, compounded with the added embarrassment of a buggy product.  

We can do a lot of things bad, or a few things well. The most obvious truth that somehow becomes unintuitive in the software engineering trenches. Leadership's ability to present clear goals and a unified direction enables a team’s focus on a tangible deliverable. Disparate sources of requirements, products wanted, and shifting deliverables is a sure way to guarantee failure. While you should always leave room to adapt to new realities, you should also be able to clearly explain what the expectations and deliverable for your team are — at all times.  

Strong software leadership finds themselves repeatedly defending these simple — yet rational — truths. Software engineering is in a state of crisis because those currently leading, still perpetuate the idea that it takes a collection of genius individuals to innovate, disrupt, and produce — despite evidence to the contrary. Their planning, feature request, hiring practices and communication all seemed to be contingent upon a naive ideal. This stigma acts as a gatekeeper to a lot of bright and rational minds — who altogether would prefer to avoid it — when we need them the most. It’s tech leadership’s responsibility to act rationally and promote practices which both enable a team’s success and encourage acceptance. Further, rehabilitating our expectations and planning will result in better products, delivered on time. 